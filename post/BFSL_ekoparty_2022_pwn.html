<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Miguel MZ - Research</title>
    <link rel="shortcut icon" href="../images/icon.png">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/bootstrap4-neon-glow.min.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
    <link rel='stylesheet' href='//cdn.jsdelivr.net/font-hack/2.020/css/hack.min.css'>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  </head>
  <body>

 <div class="navbar-dark text-white">
    <div class="container">
      <nav class="navbar px-0 navbar-expand-lg navbar-dark">
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
          <div class="navbar-nav">
            <a href="../index.html" class="pl-md-0 p-3 text-light" style="font-family:courier,arial,helvética"> # Start</a>
            <a href="../whoami.html" class="p-3 text-decoration-none text-light" style="font-family:courier,arial,helvética"> # Whoami</a>
            <a href="../TEB_PEB.html" class="p-3 text-decoration-none text-light" style="font-family:courier,arial,helvética"> # TeB/PeB</a>
          </div>
        </div>
      </nav>
    </div>
  </div>

<div class="jumbotron bg-transparent mb-0 radius-0">
  <div class="container">
      <div class="row">
        <div class="">
          <h1 class="display-1" style="font-family:courier,arial,helvética">kd❯ <span class="vim-caret" style="font-family:courier,arial,helvética">g</span></h1>
          <div class="lead mb-3 text-mono text-success" style="font-size: 25px;font-family:courier,arial,helvética">fffff803'00000000 EB FE jmp short loc_HackinG</div>
          <p class="mt-5 text-grey text-spacey">
            <h1 style="font-family:courier,arial,helvética">~ ./priv</h1><br><br>
            <table border="0" width="100%">
                <tr>
                  <td style="font-size: 30px; color: aliceblue;font-family:courier,arial,helvética;">
                    Windows Exploitation Challenge - Blue Frost Security 2022
                  </td>
                </tr>
                <tr>
                  <td>
                    <hr>
                  </td>
                </tr>
                <tr>
                  <td align="justify" style="font-size: 20px; color: aliceblue;font-family:courier,arial,helvética;">
                    <p>
						Hola y bienvenidos a todos los lectores.<br><br>
						Como todos los años participo de Ekoparty Conference e intento absorber lo mas que pueda en conocimiento de los speaker y de personas que voy conociendo en el camino. Por esta razón, muchas veces me pierdo de divertidos retos y termino resolviéndolos después de tiempo.<br><br>
						Perdiendo la oportunidad de algún tipo de recompensa jeje. Pero bueno lo importante es resolverlo, aun así, se gana experiencia.<br><br>
						Entonces para ya comenzar con lo importante que es resolver el reto de este año, primero pasaremos por los requisitos impuestos por <b style="color: brown;">Blue Frost Security Labs en Ekoparty 2022</b>.<br><br>
						Requisitos:<br><br>
						1.	Solo se aceptarán soluciones de Python sin bibliotecas externas<br>
						2.	El objetivo es ejecutar la Calculadora de Windows (calc.exe)<br>
						3.	La solución debería funcionar en Windows 10 o Windows 11<br>
						4.	La continuación del proceso es deseable (no obligatoria)<br><br>
						Descarga de la aplicación:<br>
						<a href="https://static.bluefrostsecurity.de/files/lab/bfs-eko2022.zip" style="color: cornflowerblue" target="_blank">https://static.bluefrostsecurity.de/files/lab/bfs-eko2022.zip</a><br><br>

						<h2><u><b>Protecciones</b></u></h2><br>

						Las protecciones de un binario son aplicadas para evitar que una posible explotación sea de manera trivial, aumentando la dificultad de explotación.<br><br>
						Utilizamos la herramienta de <b style="color: brown;">winhecksec.exe</b>, el cual nos muestra que el binario tiene habilitado la protección ASLR, DEP y GS que no se visualiza, pero reversando se puede validar.<br><br>

						<center><img src="../images/bfs1.png" width="55%"></center><br>
						<center>
							<table border="1">
								<tr><td><b style="color: chartreuse;">ASLR</b></td><td>Cambia las direcciones de memoria en cada ejecución</td></tr>
								<tr><td><b style="color: chartreuse;">DEP</b></td><td>Evita ejecutar shellcode en el Stack</td></tr>
								<tr><td><b style="color: chartreuse;">GS</b></td><td>Detecta desbordamientos que sobrescriben el retorno</td></tr>
							</table>
						</center><br><br>

						<h2><u><b>Análisis</b></u></h2><br>

						Lo primero es lo primero, así que vamos a ejecutar el binario y vemos que levanta un servicio socket en algún puerto.<br><br>
						<center><img src="../images/bfs2.png" width="60%"></center><br>
						Utilizamos <b style="color: brown;">Process Hacker</b> y en la pestaña Network filtramos por el nombre del binario y vemos que el servicio corre en el 31415. Esta es la manera mas fácil de identificar el puerto. Otra forma seria reversando y ver los parámetros de la función <b style="color: brown;">listen()</b>, pero para que nos vamos a complicar.<br><br>
						<center><img src="../images/bfs3.png" width="80%"></center><br>
						Ya con esto creamos la primera estructura del script para que se comunique con el servicio. Este lo utilizaremos mas adelante en el análisis dinámico, por ahora vamos a ir reconociendo el flujo de forma estática.<br><br>

						<textarea class="form-control" rows="20" cols="100" disabled>
#!/usr/bin/python
# Code By s1kr10s
import socket

server = "127.0.0.1"
port = 31415

try:
    junk = A" * 1000

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server, port))
    s.send(junk)
    s.recv(1024)
    s.close()

except Exception as e:
    print(e)
						</textarea><br>
						Viendo el código identificamos primeramente la función <b style="color: brown;">main()</b>, donde aquí se ejecutan las siguientes acciones que levantan el servicio y realiza algunas comprobaciones de los datos enviados.<br><br>
						<center><img src="../images/bfs4.png" width="70%"></center><br>
						Lo mas importante de aquí es <b style="color: brown;">cmp_msg_hello()</b> que se encarga de comparar los bytes recibidos con una constante llamada “Hello”, si es así sigue el camino correcto al <b style="color: brown;">send()</b> para responder con un “Hi” mediante la conexión socket y poder llegar a la función <b style="color: brown;">packet_filter()</b>.<br><br>
						<center><img src="../images/bfs5.png" width="50%"></center><br>
						Ahora vemos las rutinas de <b style="color: brown;">packet_filter()</b>, es aquí donde se encuentran las vulnerabilidades y donde hay que pensar.<br><br>
						<center><img src="../images/bfs6.png" width="70%"></center><br>

						Cuando entra a la función se ejecuta una especie de <b style="color: brown;">memset()</b> sobre el buffer de <b style="color: brown;">virtualAlloc()</b>, modificando los bytes existentes por unos definidos por el binario (5050505050… y CF58585858…) los que tienen un propósito.<br><br>
						<center><img src="../images/bfs7.png" width="60%"></center><br>
						El segundo <b style="color: brown;">recv()</b> recibe una especie de cabecera de paquete que será utilizado para distintas validaciones como tamaño, cookie y el tipo.<br><br>
						1. <b style="color: brown;">size</b> valida que la cabecera sea menor o igual a 11 bytes de tamaño<br>
						2. <b style="color: brown;">cookie</b> valida que se envié la cadena Eko2022<br>
						3. <b style="color: brown;">type</b> valida que se envié el carácter “T”<br>
						4. <b style="color: brown;">Integer Overflow</b> es un valor que pertenece a la cabecera llamado <b style="color: brown;">size</b> y debe ser menor a 0x0F00 que en decimal es 3840<br><br>

						Aquí podemos ver que existe una comparación con signo, el cual nos permite explotar la vulnerabilidad de Integer Overflow enviando un valor negativo que pronto será interpretado como positivo.<br><br>
						Entonces si en el valor <b style="color: brown;">size</b> de la cabecera enviamos 0xFFFF esto será transformado a 0x0000FFFF el cual es negativo y menor a 0x0F00 logrando la evasión de comparación.<br><br>
						<center><img src="../images/bfs8.png" width="70%"></center><br>
						Cuando se logra la evasión entramos a llama otro <b style="color: brown;">recv()</b> pero con un tamaño que controlamos, en este caso seria el word del valor negativo 0x0000<b style="color: brown;">FFFF</b> y los bytes serán copiados a un buffer ubicado en el heap.<br><br>
						Seguido se hace una llamada a la función renombrada como <b style="color: brown;">copy_data_heap_to_stack()</b> con los argumentos.<br><br>

						<center>
							<table border="1">
								<tr><td><b style="color: chartreuse;">len</b></td><td>Es el tamaño devuelto por el recv()</td></tr>
								<tr><td><b style="color: chartreuse;">buf</b></td><td>Es el buffer de heap</td></tr>
								<tr><td><b style="color: chartreuse;">cmdLine</b></td><td>Es un buffer de stack de 3840 bytes</td></tr>
							</table>
						</center><br>
						<center><img src="../images/bfs9.png" width="65%"></center><br>

						Dentro de <b style="color: brown;">copy_data_heap_to_stack()</b> tenemos una rutina que realiza una copia byte a byte desde el buffer heap al buffer stack, mediante un ciclo for() utilizando como size el 0xFFFF, provocando un desbordamiento de buffer de stack. Ahora lo importante es poder controlar registros o variables de stack que nos permitan seguir con la ejecución, para eso es necesario enviar bytes de tamaño controlado para poder modificar el valor del tipo y poder llegar a <b style="color: brown;">winExec()</b>.<br><br>
						<center><img src="../images/bfs10.png" width="40%"></center><br>
						Antes de llamar a <b style="color: brown;">winExec()</b> se realiza un desplazamiento dentro del buffer y esos bytes son movidos al registro rax el que pisa la dirección de winExec(), por lo tanto no se podrá utilizar la función para ejecutar código. Por ultimo se realiza la llamada.<br><br>
						<center><img src="../images/bfs11.png" width="60%"></center><br>
						Si recuerdan en la función <b style="color: brown;">memset()</b> se modifican los bytes del buffer con 5050505050 y CF58585858. Ahora con el desplazamiento dentro del buffer mas 7 bytes, nos posicionamos justo en los 5050505050. Entonces cuando se realiza la llamada a <b style="color: brown;">winExec()</b> llegamos a los 5050505050, los que se transforman en “<b style="color: brown;">pop rax</b>” permitiendo hacer pop al stack y tomar el control del retorno que serian nuestras A’s con <b style="color: brown;">iret</b>.<br><br>
						Para esto veremos los <b style="color: brown;">pop rax</b> y validamos con la información del stack.<br><br>
						<center><img src="../images/bfs12.png" width="45%"></center><br>
						Con el siguiente código se comprueba los explicado anteriormente.<br><br>
						<textarea class="form-control" rows="20" cols="100" disabled>
#!/usr/bin/python
# Code By s1kr10s
import socket
import struct
from sys import exit

server = "127.0.0.1"
port = 31415

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server, port))
    
    print("[+] Sending Handshake (Hello)")
    hello = "\x48\x65\x6c\x6c\x6f\x00"                  # invalid handshake
    s.send(hello)
    welcome = s.recv(3)
    
    if len(welcome) == 3:
        print("   [-] Response of Hello is: %s" % welcome)
    
        header  = "\x45\x6b\x6f\x32\x30\x32\x32\x00"   # wrong cookie value
        header += "\x54"                               # invalid packet type
        header += "\xff\xff"                           # invalid packet size
        print("   [-] Header Length %d" % len(header))
        
        
        size  = 3840                            # size 0x0f00
        data  = struct.pack("<I", 0x41)         # return iret (EIP)
        data += "\x90" * (size - len(data))     # junk bytes
        data += "\x58"                          # type - cmp eax, 58h ; 'X'
        data += "\x90" * 7                      # offset to XXXXXXX
        print("   [-] Data Length %d" % len(data))
                
        print("[+] Sending Payload")
        payload = header + data
        s.send(payload)
        recibe2 = s.recv(20)
        print("   [-] Response: %s" % recibe2)
        
    else:
        print("I'm Sorry I don't know him")
        exit()
        
except Exception as e:
    print(e)
						</textarea><br>

						Ahora ya estamos casi al final del reto, pero para lograrlo hay que solucionar el problema de <b style="color: brown;">iret</b> ya que demás de la dirección de retorno (EIP/RIP) ubicada en el stack, también necesita otros argumentos.<br><br>
						El iret es una instrucción que generalmente se llama desde el código del kernel antes de regresar a un proceso de espacio de usuario.<br><br>

						Referencias sobre iret y segmentación Intel:<br>
						<a href="https://www.inventati.org/nophear/download_tesi.pdf" style="color: cornflowerblue" target="_blank">https://www.inventati.org/nophear/download_tesi.pdf</a><br>
						<a href="http://jamesmolloy.co.uk/tutorial_html/10.-User%20Mode.html" style="color: cornflowerblue" target="_blank">http://jamesmolloy.co.uk/tutorial_html/10.-User Mode.html</a><br>
						<a href="https://nixhacker.com/segmentation-in-intel-64-bit/" style="color: cornflowerblue" target="_blank">https://nixhacker.com/segmentation-in-intel-64-bit</a><br>
						<a href="https://www.malwaretech.com/2014/02/the-0x33-segment-selector-heavens-gate.html" style="color: cornflowerblue" target="_blank">https://www.malwaretech.com/2014/02/the-0x33-segment-selector-heavens-gate.html</a><br><br>

						Por hora lo que debemos lograr hacer es un <b style="color: brown;">Fake iret Frame</b> en el stack, y debe contener los siguientes parámetros.<br><br>
						<center>
							<table border="1">
								<tr><td><b style="color: chartreuse;">EIP</b></td><td>The instruction to continue execution at – the value of EIP</td></tr>
								<tr><td><b style="color: chartreuse;">CS</b></td><td>The code segment selector to change to</td></tr>
								<tr><td><b style="color: chartreuse;">EFLAGS</b></td><td>The value of the EFLAGS register to load</td></tr>
								<tr><td><b style="color: chartreuse;">ESP</b></td><td>The stack pointer to load</td></tr>
								<tr><td><b style="color: chartreuse;">SS</b></td><td>The stack segment selector to change to</td></tr>
							</table>
						</center><br>

						• <b style="color: chartreuse;">EIP</b> es la dirección del inicio del buffer ubicado en el heap en 0x10000000 donde tenemos nuestra data. Pero le daremos un desplazamiento para evitar cualquier tipo de problema quedando en 0x10000014.<br>
						• <b style="color: chartreuse;">CS</b> indexa la Global Descriptor Table (GDT) con su descriptor code/data en kernel (ring0) y user (ring3).<br>
						• <b style="color: chartreuse;">EFLAGS</b> lo podemos obtener con windbg o x64dbg en el registro afl.<br>
						• <b style="color: chartreuse;">ESP</b> es una dirección en medio del buffer ubicado en el heap, pero debe estar por debajo de la shellcode y tampoco debe ser el final como 0x10000600.<br>
						• <b style="color: chartreuse;">SS</b> indexa la Global Descriptor Table (GDT) con su descriptor code/data en kernel (ring0) y user (ring3).<br><br>

						Una manera fácil de obtener el valor de <b style="color: chartreuse;">EFLAGS</b> es mediante el registro <b style="color: brown;">efl</b>, que se puede visualizar co el depurador windbg.<br><br>
						<center><img src="../images/bfs13.png" width="55%"></center><br>

						Ahora vamos a calcular el valor de <b style="color: chartreuse;">CS</b> y <b style="color: chartreuse;">SS</b>, ya que son los mas difícil de obtener.<br><br>Cuando se configura el GDT se configuran 5 selectores como el selector nulo, un selector de code/data en modo kernel y un selector de code/data en modo usuario.<br><br>

						Los índices entre Kernel y usuario tiene un tamaño de 16 bytes y entre code y data por cada modo es de 8 bytes, por lo que los índices del selector son:<br><br>
						• <b style="color: violet;">0x00</b>: Null Descriptor<br>
						• <b style="color: violet;">0x10</b>: Kernel Code Segment<br>
						• <b style="color: violet;">0x18</b>: Kernel Data Segment<br>
						• <b style="color: violet;">0x20</b>: User Code Segment<br>
						• <b style="color: violet;">0x28</b>: User Data Segment<br><br>

						Entonces si queremos pasar a modo usuario (ring3) debemos configurar en 3. Para esto nuestro selector de code segment será [<b style="color: violet;">0x20+0x3=0x23</b>] y el selector de data segment será [<b style="color: violet;">0x28+x03=0x2b</b>].<br><br>
						<center><img src="../images/bfs14.png" width="55%"></center><br><br>

						Ahora el gran problema que tenemos con el calculo de "User Data Segment", es que el <b style="color: violet;">0x2b</b> es modificado por un 0x00 al entrar a la función <b style="color: brown;">copy_data_heap_to_stack()</b>.<br><br>

						<h2><u><b>Explotación</b></u></h2><br>


                    </p>
                  </td>
                </tr>
            </table>
          </p>
        </div>
      </div>
  </div>
</div>
<!--<div class="container py-5">
  <h4>Thanks</h4>
    <a href="https://github.com/s1kr10s">https://github.com/s1kr10s</a></p>

  
</div>-->

    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->

  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

  </body>
</html>
